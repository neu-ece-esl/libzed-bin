<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libzed: src/axi_uartlite.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libzed
   </div>
   <div id="projectbrief">Convenience library to control ZedBoard FPGA peripherals</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">axi_uartlite.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="axi__uartlite_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04a8e06cbfda919684d23d870b2afdb8"><td class="memItemLeft" align="right" valign="top">struct axi_uartlite_data *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a04a8e06cbfda919684d23d870b2afdb8">axiuartlite_get</a> (unsigned long uart_base)</td></tr>
<tr class="memdesc:a04a8e06cbfda919684d23d870b2afdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize UART.  <a href="#a04a8e06cbfda919684d23d870b2afdb8">More...</a><br /></td></tr>
<tr class="separator:a04a8e06cbfda919684d23d870b2afdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6d59bb07fe947397eb91ae63ce3f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#aa2e6d59bb07fe947397eb91ae63ce3f0">axiuartlite_free</a> (struct axi_uartlite_data *inst)</td></tr>
<tr class="memdesc:aa2e6d59bb07fe947397eb91ae63ce3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initialize UART.  <a href="#aa2e6d59bb07fe947397eb91ae63ce3f0">More...</a><br /></td></tr>
<tr class="separator:aa2e6d59bb07fe947397eb91ae63ce3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06629a3ce8baa399832bbd38f7d6ca81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a06629a3ce8baa399832bbd38f7d6ca81">axiuartlite_rxfifo_full</a> (struct axi_uartlite_data *inst)</td></tr>
<tr class="memdesc:a06629a3ce8baa399832bbd38f7d6ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the RX FIFO is full.  <a href="#a06629a3ce8baa399832bbd38f7d6ca81">More...</a><br /></td></tr>
<tr class="separator:a06629a3ce8baa399832bbd38f7d6ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e75488612e84d88636f53647d8249"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#aed6e75488612e84d88636f53647d8249">axiuartlite_rxfifo_empty</a> (struct axi_uartlite_data *inst)</td></tr>
<tr class="memdesc:aed6e75488612e84d88636f53647d8249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the RX FIFO is empty.  <a href="#aed6e75488612e84d88636f53647d8249">More...</a><br /></td></tr>
<tr class="separator:aed6e75488612e84d88636f53647d8249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3a0994e1dfb579ef8c39c64930a883"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a7e3a0994e1dfb579ef8c39c64930a883">axiuartlite_txfifo_full</a> (struct axi_uartlite_data *inst)</td></tr>
<tr class="memdesc:a7e3a0994e1dfb579ef8c39c64930a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TX FIFO is full.  <a href="#a7e3a0994e1dfb579ef8c39c64930a883">More...</a><br /></td></tr>
<tr class="separator:a7e3a0994e1dfb579ef8c39c64930a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1b7b5373a710f21931209bd0df3dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a09d1b7b5373a710f21931209bd0df3dd">axiuartlite_txfifo_empty</a> (struct axi_uartlite_data *inst)</td></tr>
<tr class="memdesc:a09d1b7b5373a710f21931209bd0df3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the TX FIFO is full.  <a href="#a09d1b7b5373a710f21931209bd0df3dd">More...</a><br /></td></tr>
<tr class="separator:a09d1b7b5373a710f21931209bd0df3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a081bdff8a039651211155b5eba3bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a31a081bdff8a039651211155b5eba3bb">axiuartlite_send_bytes</a> (struct axi_uartlite_data *inst, unsigned char *buf, unsigned int size, unsigned char block)</td></tr>
<tr class="memdesc:a31a081bdff8a039651211155b5eba3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send one or more bytes. This function tries to send a number of bytes. There are two modes for sending data: blocking and non-blocking. In the non-blocking mode, the function will attempt to send the data at once. If the UART's TX FIFO becomes full while sending, the transmission is aborted and the number of successfully sent bytes is returned. In the blocking mode, the function blocks until all the data gets sent successfully, except if a timeout of 100k cycles (by default) is exceeded, in which case the transmission is aborted.  <a href="#a31a081bdff8a039651211155b5eba3bb">More...</a><br /></td></tr>
<tr class="separator:a31a081bdff8a039651211155b5eba3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cccb8119348cb7a819608b4df99ff6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a96cccb8119348cb7a819608b4df99ff6">axiuartlite_send_byte</a> (struct axi_uartlite_data *inst, unsigned char byte)</td></tr>
<tr class="memdesc:a96cccb8119348cb7a819608b4df99ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a single byte. Tries to send a single byte. If the TX FIFO is full, this will result in an error.  <a href="#a96cccb8119348cb7a819608b4df99ff6">More...</a><br /></td></tr>
<tr class="separator:a96cccb8119348cb7a819608b4df99ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72469f2abf881543f2ada08e886e342d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a72469f2abf881543f2ada08e886e342d">axiuartlite_recv_byte</a> (struct axi_uartlite_data *inst, unsigned char *byte)</td></tr>
<tr class="memdesc:a72469f2abf881543f2ada08e886e342d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a single byte. Tries to receive a single byte. If the RX FIFO is empty, this will result in an error.  <a href="#a72469f2abf881543f2ada08e886e342d">More...</a><br /></td></tr>
<tr class="separator:a72469f2abf881543f2ada08e886e342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202d950dcf7be99ec1ae8ca73ad61bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#a1202d950dcf7be99ec1ae8ca73ad61bb">axiuartlite_recv_bytes</a> (struct axi_uartlite_data *inst, unsigned char *buf, unsigned int size, unsigned char block)</td></tr>
<tr class="memdesc:a1202d950dcf7be99ec1ae8ca73ad61bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive one or more bytes. This function will try to receive a number of bytes. If the blocking mode is used, it will try to wait until the specified number of bytes is successfully received, unless a maximum timeout of 100k cycles (by default) is reached. If not using the blocking mode, the function will abort the reception of bytes in case the RX FIFO becomes empty and will return the number of bytes that were successfully received.  <a href="#a1202d950dcf7be99ec1ae8ca73ad61bb">More...</a><br /></td></tr>
<tr class="separator:a1202d950dcf7be99ec1ae8ca73ad61bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad856c57db65c5b3b636cc48ca3d9c069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="axi__uartlite_8h.html#ad856c57db65c5b3b636cc48ca3d9c069">axiuartlite_set_max_wait</a> (struct axi_uartlite_data *inst, unsigned int maxWait)</td></tr>
<tr class="memdesc:ad856c57db65c5b3b636cc48ca3d9c069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the max wait in cycles.  <a href="#ad856c57db65c5b3b636cc48ca3d9c069">More...</a><br /></td></tr>
<tr class="separator:ad856c57db65c5b3b636cc48ca3d9c069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>UART Convenience functions </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aa2e6d59bb07fe947397eb91ae63ce3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6d59bb07fe947397eb91ae63ce3f0">&#9670;&nbsp;</a></span>axiuartlite_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axiuartlite_free </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initialize UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a8e06cbfda919684d23d870b2afdb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a8e06cbfda919684d23d870b2afdb8">&#9670;&nbsp;</a></span>axiuartlite_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct axi_uartlite_data* axiuartlite_get </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>uart_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uart_base</td><td>UART base address </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to an axi_uartlite_data struct </dd></dl>

</div>
</div>
<a id="a72469f2abf881543f2ada08e886e342d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72469f2abf881543f2ada08e886e342d">&#9670;&nbsp;</a></span>axiuartlite_recv_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_recv_byte </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a single byte. Tries to receive a single byte. If the RX FIFO is empty, this will result in an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
    <tr><td class="paramname">byte</td><td>a pointer to a destination in which to save the received byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, a negative value otherwise. </dd></dl>

</div>
</div>
<a id="a1202d950dcf7be99ec1ae8ca73ad61bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202d950dcf7be99ec1ae8ca73ad61bb">&#9670;&nbsp;</a></span>axiuartlite_recv_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_recv_bytes </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive one or more bytes. This function will try to receive a number of bytes. If the blocking mode is used, it will try to wait until the specified number of bytes is successfully received, unless a maximum timeout of 100k cycles (by default) is reached. If not using the blocking mode, the function will abort the reception of bytes in case the RX FIFO becomes empty and will return the number of bytes that were successfully received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
    <tr><td class="paramname">buf</td><td>a pointer to an array to receive the bytes </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes to receive </td></tr>
    <tr><td class="paramname">block</td><td>use blocking mode or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes successfully received or a negative value in case of an error </dd></dl>

</div>
</div>
<a id="aed6e75488612e84d88636f53647d8249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6e75488612e84d88636f53647d8249">&#9670;&nbsp;</a></span>axiuartlite_rxfifo_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_rxfifo_empty </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the RX FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the FIFO is empty, 0 if not empty or a negative value in case of error </dd></dl>

</div>
</div>
<a id="a06629a3ce8baa399832bbd38f7d6ca81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06629a3ce8baa399832bbd38f7d6ca81">&#9670;&nbsp;</a></span>axiuartlite_rxfifo_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_rxfifo_full </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the RX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the FIFO is full, 0 if not full or a negative value in case of error </dd></dl>

</div>
</div>
<a id="a96cccb8119348cb7a819608b4df99ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cccb8119348cb7a819608b4df99ff6">&#9670;&nbsp;</a></span>axiuartlite_send_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_send_byte </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a single byte. Tries to send a single byte. If the TX FIFO is full, this will result in an error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
    <tr><td class="paramname">byte</td><td>the byte to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in case of success, a negative value otherwise </dd></dl>

</div>
</div>
<a id="a31a081bdff8a039651211155b5eba3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a081bdff8a039651211155b5eba3bb">&#9670;&nbsp;</a></span>axiuartlite_send_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_send_bytes </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send one or more bytes. This function tries to send a number of bytes. There are two modes for sending data: blocking and non-blocking. In the non-blocking mode, the function will attempt to send the data at once. If the UART's TX FIFO becomes full while sending, the transmission is aborted and the number of successfully sent bytes is returned. In the blocking mode, the function blocks until all the data gets sent successfully, except if a timeout of 100k cycles (by default) is exceeded, in which case the transmission is aborted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
    <tr><td class="paramname">buf</td><td>a pointer to a array of bytes to be sent </td></tr>
    <tr><td class="paramname">size</td><td>the buffer's size (amount of bytes being sent) </td></tr>
    <tr><td class="paramname">block</td><td>whether to block until all bytes are sent or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a negative value in case of failure, or the number of bytes successfully sent </dd></dl>

</div>
</div>
<a id="ad856c57db65c5b3b636cc48ca3d9c069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad856c57db65c5b3b636cc48ca3d9c069">&#9670;&nbsp;</a></span>axiuartlite_set_max_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axiuartlite_set_max_wait </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the max wait in cycles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
    <tr><td class="paramname">maxWait</td><td>the number of cycles to set as maximum wait timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d1b7b5373a710f21931209bd0df3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d1b7b5373a710f21931209bd0df3dd">&#9670;&nbsp;</a></span>axiuartlite_txfifo_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_txfifo_empty </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the FIFO is empty, 0 if not empty or a negative value in case of error </dd></dl>

</div>
</div>
<a id="a7e3a0994e1dfb579ef8c39c64930a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3a0994e1dfb579ef8c39c64930a883">&#9670;&nbsp;</a></span>axiuartlite_txfifo_full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axiuartlite_txfifo_full </td>
          <td>(</td>
          <td class="paramtype">struct axi_uartlite_data *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the TX FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inst</td><td>a pointer to an axi_uartlite_data struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the FIFO is full, 0 if not full or a negative value in case of error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
